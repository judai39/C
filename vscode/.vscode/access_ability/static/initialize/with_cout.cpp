/*
*首先定义几个规定:
*   1.结果执行与打印出结果是两回事
*   2.如果不对流进行刷新,在这之流之后执行的语句均不会被打印
*   3.刷新流功能的有:endl(换行并刷新),flush(仅执行刷新功能)
*   4.cout的作用是新建一个流,使用<<向流中加入想要打印的信息
*   5.想要使用流的功能,可在对应的作用域声明命名空间using namespace std; 或者std::cout静态调用
*   6.在C++中，当我们说“刷新流”，我们指的是清空输出缓冲区，确保所有的输出数据都被立即写入到其目标设备（比如说控制台或者文件）。
*    首先，为了效率，C++的I/O操作通常是缓冲的。这意味着当你执行一个输出操作，如cout << "Hello";，数据可能首先被写入一个内部缓冲区，
*    而不是直接发送到其最终目的地。当缓冲区满时，数据会自动被送出。但有时候，你可能希望立即送出数据，即使缓冲区还没有满。这就是刷新流的作用。
*/
#include<iostream>
using namespace std;

class Test{
    public:
    int num;
    static int static_num;
    static void print(){
        /*对于局部变量的初始化,不像全局变量那样初始默认0,而是取决于它的数据类型和位置的随机数*/
        //问题来了,将35行的cout流刷新后默认分配依然是0
        int n;

        cout<<"这是一个局部未初始化量"<<n<<endl;
        //静态量无论是否全局,其默认初始化均为0;(但默认的赋值语句还是不能放在类中,可以放在30行)
        cout<<"这是一个静态量"<<static_num<<endl;
        
    }
};
int Test::static_num;
int main(){
    cout<<"未在该流后刷新,这之后的信息只有在缓冲区满时才会被输出至控制台"<<endl;
    Test test=Test();
    //全局变量的初始化默认0
    cout<<test.num;
    test.print();
    test.print();
    cout<<"两次调用print(),num的值为"<<test.num<<"说明方法print()的确执行成功"<<endl;
}
